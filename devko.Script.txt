/**
 *	Rounds mode
 */
#Extends "Libs/Nadeo/TMNext/TrackMania/Modes/TMNextRoundsBase.Script.txt"

#Const	CompatibleMapTypes	"TrackMania\\TM_Race,TM_Race"
#Const	Version							"2021-09-01"
#Const	ScriptName					"Modes/TrackMania/TM_Rounds_Online.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/CommonLibs/Common/Semver.Script.txt" as Semver
#Include "Libs/Nadeo/ModeLibs/Common/Utils.Script.txt" as ModeUtils
#Include "Libs/Nadeo/TMNext/TrackMania/Menu/Constants.Script.txt" as MenuConsts
#Include "ManiaApps/Nadeo/TMNext/TrackMania/Knockout/UIModules/KnockoutInfo_Server.Script.txt" as UIModules_KnockoutInfo
#Include "Libs/Nadeo/TMNext/TrackMania/Modes/Rounds/StateManager.Script.txt" as StateMgr
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/ScoresTable_Server.Script.txt" as UIModules_ScoresTable
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/Checkpoint_Server.Script.txt" as UIModules_Checkpoint
#Include "ManiaApps/Nadeo/TMxSM/Race/UIModules/PauseMenuOnline_Server.Script.txt" as UIModules_PauseMenu_Online

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_ScriptEnvironment "test" //Active the developement environement

#Setting S_StartPoint 100 as _("Start Point") // Number of  point at the start of the game for each players
#Setting S_MaxPointLoss 50 as _("Max Point Loss") // Max number of point that a player can lose in a round
#Setting S_PenalityPointforDNF 10 as _("Penality Point DNF") //Penality point for the guys who DNF


#Setting S_DebugLosePointAtFirst False as _("Debug Lose Point When First") 
#Setting S_CastersLogins "" as _("Casters Logins")

#Setting S_PointsLimit 50 as _("Points limit")
#Setting S_FinishTimeout -1 as _("Finish timeout")
#Setting S_RoundsPerMap -1 as _("Number of rounds per map") ///< Number of round to play on one map before going to the next one
#Setting S_MapsPerMatch -1 as _("Number of maps per match") ///< Number of maps to play before finishing the match
#Setting S_UseTieBreak True as _("Use tie-break")	///< Continue to play the map until the tie is broken
#Setting S_WarmUpNb 0	as _("Number of warm up")
#Setting S_WarmUpDuration 0 as _("Duration of one warm up")
#Setting S_WarmUpTimeout -1 as _("Warm up timeout")


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_ModeName "Rounds"
//L16N [Rounds] Description of the mode rules
#Const Description _("$zIn $<$t$6F9Rounds$z$z$> mode, the goal is to win a maximum number of $<$t$6F9points.\n\n$z$>The rounds mode consists of $<$t$6F9a series of races$z$>.\nWhen you finish a race in a good $<$t$6F9position$z$>, you get $<$t$6F9points$z$>, added to your total.\n\nThe $<$t$6F9winner$z$> is the first player whose total reaches the $<$t$6F9point limit$z$> (30 for example).")

#Const C_HudModulePath "" //< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/TMNext/TrackMania/Rounds/Rounds.Script.txt" //< Url of the mania app
#Const C_FakeUsersNb 0

#Const C_PointsLimit_NotReached 0
#Const C_PointsLimit_Reached 1
#Const C_PointsLimit_Tie 2

#Const C_UploadRecord True
#Const C_DisplayRecordGhost False
#Const C_DisplayRecordMedal False
#Const C_CelebrateRecordGhost True
#Const C_CelebrateRecordMedal True

#Struct K_MatchInfo {
	Boolean RegistrationClosed; // Terminer le processus d'inscription
	Integer[Text] PlayerStatus; // from -1 non player / spec, 0 eliminated player, 1 means still alive, 2 is the winner
	Integer[Text] PlayerRanks; //define the ranks of players by 1 to Players Nbr
	Integer[Text] MinAlivePos; //define the minimum pos before ko for each player at each round.
	Boolean[Text] CanDisPlayerPlay; //check if the player is disconneted for more than a round
	Text[] PlayerIsOnServer;
	Text[] CastersLogins;
	Boolean FirstRoundOver;
	Integer ParticipantsNb;
	Integer KOPlayersNb;
	Integer NbOfRoundPlayers;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ***Match_LogVersions***
// ***
// Log::RegisterScript(ScriptName, Version);
// Log::RegisterScript(Semver::ScriptName, Semver::Version);
// Log::RegisterScript(ModeUtils::ScriptName, ModeUtils::Version);
// Log::RegisterScript(StateMgr::ScriptName, StateMgr::Version);
// ***

***Match_LoadLibraries***
***
StateMgr::Load();
***

***Match_UnloadLibraries***
***
StateMgr::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = (C_HudModulePath == "");
***

***Match_Rules***
***
ModeInfo::SetName(C_ModeName);
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage("");

declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
///CLEAR
Server_MatchInfo.PlayerIsOnServer.clear();
Server_MatchInfo.PlayerStatus.clear();
Server_MatchInfo.CanDisPlayerPlay.clear();
Server_MatchInfo.PlayerRanks.clear();
Server_MatchInfo.MinAlivePos.clear();
Server_MatchInfo.CastersLogins.clear();
Server_MatchInfo.FirstRoundOver = False;
Server_MatchInfo.CastersLogins = ConvertCastersLogin(S_CastersLogins);
***

***Match_LoadHud***
***
if (C_HudModulePath != "") Hud_Load(C_HudModulePath);
***

***Match_AfterLoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
Race::SortScores(Race::C_Sort_TotalPoints);
UIModules_ScoresTable::SetScoreMode(UIModules_ScoresTable::C_Mode_Points);
UIModules_Checkpoint::SetVisibilityTimeDiff(False);
UIModules_Checkpoint::SetRankMode(UIModules_Checkpoint::C_RankMode_CurrentRace);
UIModules_PauseMenu_Online::SetHelp(Description);
// Hide SM Overlay
UIManager.UIAll.OverlayHideSpectatorControllers = True;
UIManager.UIAll.OverlayHideSpectatorInfos = True;
UIManager.UIAll.OverlayHideChrono = True; 
UIManager.UIAll.OverlayHideCountdown = True;
***

***Match_Yield***
***

foreach (Event in PendingEvents) {
	switch (Event.Type) {
		// Initialize players when they join the server
		case CSmModeEvent::EType::OnPlayerAdded: {
			declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
			StateMgr::InitializePlayer(Event.Player);
			CarRank::InitializePlayer(Event.Player);
			declare Text AccountId = Event.Player.User.Login;
			if(!Server_MatchInfo.PlayerIsOnServer.exists(AccountId)){ //check if the player was already register
				Server_MatchInfo.PlayerIsOnServer.add(AccountId);
			}
			if(Server_MatchInfo.CastersLogins.exists(AccountId)){ //check if the player is a caster
				Server_MatchInfo.PlayerStatus[AccountId] = -1;
				ServerAdmin.ForceSpectator(Event.Player.User,CServerAdmin::ESpecMode::SpectatorForced);
			}else{
				if(Event.Player != Null && !Server_MatchInfo.CanDisPlayerPlay.existskey(AccountId)){ 
					if(Server_MatchInfo.FirstRoundOver){
						Server_MatchInfo.PlayerStatus[AccountId] = 0;
						ServerAdmin.ForceSpectator(Event.Player.User,CServerAdmin::ESpecMode::SpectatorForced);
						Log::Log("PlayerStatus "^Server_MatchInfo.PlayerStatus[AccountId]);
						
					}else{
						if(!Server_MatchInfo.PlayerStatus.existskey(AccountId)){
							Server_MatchInfo.PlayerStatus[AccountId] = 1;
							Log::Log("PlayerStatus "^Server_MatchInfo.PlayerStatus[AccountId]);
							Log::Log("AccountID"^AccountId);
							Log::Log("WebService"^Event.Player.User.WebServicesUserId);
						}	
					Scores::SetPlayerMatchPoints(Event.Player.Score, S_StartPoint); 
					}
				}			
				if(Event.Player != Null && Server_MatchInfo.CanDisPlayerPlay.existskey(AccountId)){
					Server_MatchInfo.CanDisPlayerPlay.removekey(AccountId);
					if(Server_MatchInfo.PlayerStatus[AccountId] < 1){
						ServerAdmin.ForceSpectator(Event.Player.User,CServerAdmin::ESpecMode::SpectatorForced);
					}
				}
			}
			
		}
		case CSmModeEvent::EType::OnPlayerRemoved:{
			declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
			declare Text AccountId = Event.User.Login;
			Server_MatchInfo.CanDisPlayerPlay[AccountId] = Server_MatchInfo.PlayerStatus[AccountId] == 1;
			Server_MatchInfo.PlayerIsOnServer.remove(AccountId);
		}
	}
}

StateMgr::Yield();
***

***Match_InitServer***
***
Log::Log("InitServer");
declare Integer Server_PointsLimit;
declare Integer Server_RoundsPerMap;
declare Integer Server_MapsPerMatch;
***

***Match_StartServer***
***
Log::Log("StartServer");
// Layers::Create("MyOwnUI", """
// <manialink version="3">
// <label pos="-160 0" z-index="0" text="Waaah cÃ© bo" />
// </manialink>
// """);
Layers::Attach("MyOwnUI");
// Initialize mode
Clans::SetClansNb(0);
Scores::SaveInScore(Scores::C_Points_Match);
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
Race::SetRespawnBehaviour(Race::C_RespawnBehaviour_Normal);
WarmUp::SetAvailability(True);
Race::SetupRecord(
	MenuConsts::C_ScopeType_Season,
	MenuConsts::C_ScopeType_PersonalBest,
	MenuConsts::C_GameMode_Rounds,
	"",
	C_UploadRecord,
	C_DisplayRecordGhost,
	C_DisplayRecordMedal,
	C_CelebrateRecordGhost,
	C_CelebrateRecordMedal
);
Race::UseAutomaticDossardColor(False);
Server_PointsLimit = S_PointsLimit - 1;
Server_RoundsPerMap = S_RoundsPerMap - 1;
Server_MapsPerMatch = S_MapsPerMatch - 1;
***

***Match_InitMap***
***
Log::Log("InitMap");
declare Integer Map_ValidRoundsNb;
declare Boolean Map_Skipped;


//UpdateScoresTableFooter(S_PointsLimit, S_RoundsPerMap, S_MapsPerMatch, Map_ValidRoundsNb);
***

***Match_StartMap***
***
Log::Log("StartMap");
declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};

Scores::EnablePlayerNegativePoints(True,True,True); 

foreach (Score in Scores) {
	
	if (Score != Null) {	
	declare AccountId = Score.User.Login; //test login instead of id
	if(!Server_MatchInfo.PlayerIsOnServer.exists(AccountId)){
		//declare AccountId = Score.User.WebServicesUserId;	
		Server_MatchInfo.PlayerIsOnServer.add(AccountId); //Initialize the list of present player on the server
	}
	if(Server_MatchInfo.CastersLogins.exists(AccountId)){
		Server_MatchInfo.PlayerStatus[AccountId] = -1;
		Scores::SetPlayerMatchPoints(Score, 0);
		ServerAdmin.ForceSpectator(Score.User,CServerAdmin::ESpecMode::SpectatorForced);
	}else{
		if(!Server_MatchInfo.PlayerStatus.existskey(AccountId)){
			Server_MatchInfo.PlayerStatus[AccountId] = 1; //Intinialize all people to player
		}
	}
	
	Scores::SetPlayerMatchPoints(Score, S_StartPoint); //Initialize the players point
	}

	
	
	
}

UpdateNameDisplay();

SetPlayersState(Server_MatchInfo); //Execute
///INITIALIZE
Server_MatchInfo.RegistrationClosed = False; //TBD
Server_MatchInfo.FirstRoundOver = False;
Server_MatchInfo.ParticipantsNb = 0; 
Server_MatchInfo.KOPlayersNb = 0;


// // Add bot when necessary
//Users_SetNbFakeUsers(C_FakeUsersNb, 10);

Map_Skipped = True;
CarRank::Reset();

// Warm up
UIModules_ScoresTable::SetFooterInfo(_("Warm up"));
MB_WarmUp(S_WarmUpNb, S_WarmUpDuration * 1000, S_WarmUpTimeout * 1000);
***

***Match_StartRound***
***
Log::Log("StartRound");
//UpdateScoresTableFooter(S_PointsLimit, S_RoundsPerMap, S_MapsPerMatch, Map_ValidRoundsNb);
declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
Server_MatchInfo.NbOfRoundPlayers = 0;
foreach (Score in Scores) {
	declare AccountId = Score.User.Login;
	if(Server_MatchInfo.PlayerStatus[AccountId] == 1 && Server_MatchInfo.PlayerIsOnServer.exists(AccountId)){
		Server_MatchInfo.NbOfRoundPlayers += 1;
	}
}
foreach (Player in Players) {
	if(Player != Null){
		declare AccountId = Player.User.Login;
		declare Score <=> Player.Score;
		declare PlayerPoints = Scores::GetPlayerMatchPoints(Score);
		declare Real PPNumerateur =  ML::ToReal(PlayerPoints*(Server_MatchInfo.NbOfRoundPlayers-1));
		declare Real MPLDenominateur =  ML::ToReal(S_MaxPointLoss);
		declare Real Pos = PPNumerateur/MPLDenominateur;
		declare Real PPoints = ML::ToReal((S_PenalityPointforDNF * S_MaxPointLoss) / 100);
		declare Integer PenalityPoints = ML::FloorInteger(PPoints);
		//declare MinAlivePos = 
		Server_MatchInfo.MinAlivePos[AccountId] = ML::CeilingInteger(Pos - 0.0005); //0.0005 is for the case where the ceiling is not accurate when Pos is an integer		
		if(Server_MatchInfo.MinAlivePos[AccountId] == 1){
			UIModules_BigMessage::SetOffset(<0., -40.>);
			UIModules_BigMessage::SetMessage(Player, "Win the race to stay alive ", 2500);
		}else if(Server_MatchInfo.MinAlivePos[AccountId] < Server_MatchInfo.NbOfRoundPlayers){
			UIModules_BigMessage::SetOffset(<0., -40.>);
			UIModules_BigMessage::SetMessage(Player, "Be in the top "^Server_MatchInfo.MinAlivePos[AccountId]^" to stay alive", 2500);
		}else if(PlayerPoints < S_MaxPointLoss + PenalityPoints){
			UIModules_BigMessage::SetOffset(<0., -40.>);
			UIModules_BigMessage::SetMessage(Player, "Finish the race to stay alive ", 2500);
		}
	}
	
}


StateMgr::ForcePlayersStates([StateMgr::C_State_Playing]);

***

***Rounds_PlayerSpawned***
***
CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRace);
***

***Match_PlayLoop***
***
// Manage race events
declare RacePendingEvents = Race::GetPendingEvents();
foreach (Event in RacePendingEvents) {
	Race::ValidEvent(Event);
	// Waypoint
	if (Event.Type == Events::C_Type_Waypoint) {
		CarRank::ThrottleUpdate(CarRank::C_SortCriteria_CurrentRace);
		if (Event.Player != Null) {

			if (Event.IsEndRace) {
				Scores::UpdatePlayerBestRaceIfBetter(Event.Player);
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
				Scores::UpdatePlayerPrevRace(Event.Player);
				ComputeLatestRaceScores();
				Race::SortScores(Race::C_Sort_TotalPoints);
				// Start the countdown if it's the first player to finish
				if (EndTime <= 0) {
					EndTime = GetFinishTimeout(S_FinishTimeout);
				}
			}
			if (Event.IsEndLap) {
				Scores::UpdatePlayerBestLapIfBetter(Event.Player);
			}
			//Race::SortScores(Race::C_Sort_BestRaceCheckpointsProgress);
			declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
			declare pos = 1;			
			Race::SortScores(Race::C_Sort_BestRaceCheckpointsProgress);
			foreach(Score in Scores){
				if(Score != Null){
					declare AccountId = Score.User.Login;
					Log::Log("accountid "^AccountId);
					if(Server_MatchInfo.PlayerStatus[AccountId] == 1){
						declare Playerfs <=> GetPlayer(Score.User.Login);
						if(pos > Server_MatchInfo.MinAlivePos[AccountId]){
							Log::Log("if "^pos);
							Playerfs.Dossard_Color = <0.7, 0., 0.>;
						}else{
							Log::Log("else "^pos);
							Playerfs.Dossard_Color = Race::C_DossardColor_Default;						
						}
						pos += 1;
					}					
				}				
			}
		}	

	}



}

// Manage mode events
foreach (Event in PendingEvents) {
	if (Event.HasBeenPassed || Event.HasBeenDiscarded) continue;
	Events::Invalid(Event);
}

// // Server info change
// if (
// 	Server_PointsLimit != S_PointsLimit ||
// 	Server_RoundsPerMap != S_RoundsPerMap ||
// 	Server_MapsPerMatch != S_MapsPerMatch
// ) {
// 	Server_PointsLimit = S_PointsLimit;
// 	Server_RoundsPerMap = S_RoundsPerMap;
// 	Server_MapsPerMatch = S_MapsPerMatch;
	
// 	UpdateScoresTableFooter(S_PointsLimit, S_RoundsPerMap, S_MapsPerMatch, Map_ValidRoundsNb);
// }
***

***Match_EndRound***
***
Log::Log("End Round");
declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
Race::StopSkipOutroAll();
EndTime = -1;
StateMgr::ForcePlayersStates([StateMgr::C_State_Waiting]);
CarRank::Update(CarRank::C_SortCriteria_CurrentRace);
if (Semver::Compare(XmlRpc::GetApiVersion(), ">=", "2.1.1")) {
	Scores::XmlRpc_SendScores(Scores::C_Section_PreEndRound, "");
}
if (Round_ForceEndRound || Round_SkipPauseRound || Round_Skipped) {
	// Cancel points
	foreach (Score in Scores) {
		if(Score != Null){
			
			Scores::SetPlayerRoundPoints(Score, 0);
		}

	}
	// Do not launch the forced end round sequence after a pause
	if (!Round_SkipPauseRound) {
		ForcedEndRoundSequence();
	}
} else {

	foreach (Score in Scores) {
		declare AccountId = Score.User.Login; 
		if(!Server_MatchInfo.PlayerIsOnServer.exists(AccountId) && Server_MatchInfo.PlayerStatus[AccountId] > 0){
			if(Server_MatchInfo.CanDisPlayerPlay[AccountId]){
				Server_MatchInfo.CanDisPlayerPlay[AccountId] = False;
			}else{
				Server_MatchInfo.PlayerStatus[AccountId] = 0;
			}
		}
		
	}

	Map_ValidRoundsNb += 1;
	// Get the last round points
	ComputeLatestRaceScores();
	Race::SortScores(Race::C_Sort_TotalPoints);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	MB_Sleep(3000);
	// Add them to the total scores
	ComputeScores();
	Race::SortScores(Race::C_Sort_TotalPoints);
	if(Server_MatchInfo.ParticipantsNb == 0){
		Server_MatchInfo.ParticipantsNb = Server_MatchInfo.PlayerIsOnServer.count - Server_MatchInfo.CastersLogins.count; //Nb of players - the casters
	}
	foreach (Score in Scores) {
		
		
		if (Score != Null) {
	 		declare Integer PlayerPoint = Scores::GetPlayerMatchPoints(Score);
			//declare AccountId = Player.Score.User.WebServicesUserId; 
			declare AccountId = Score.User.Login; 
			if(S_DebugLosePointAtFirst){
				if(PlayerPoint >= 0)
				{
					Scores::SetPlayerMatchPoints(Score, 0);
					Server_MatchInfo.PlayerStatus[AccountId] = 0;	
				}	
				continue;
			}
			if(PlayerPoint <= 0 && Server_MatchInfo.PlayerStatus[AccountId] > 0){
				Server_MatchInfo.PlayerStatus[AccountId] = 0;	
				Server_MatchInfo.PlayerRanks[AccountId] = Server_MatchInfo.ParticipantsNb - Server_MatchInfo.KOPlayersNb;			
				Server_MatchInfo.KOPlayersNb += 1;
				Scores::SetPlayerMatchPoints(Score, -S_MaxPointLoss - Server_MatchInfo.PlayerRanks[AccountId]);
			}else if(Server_MatchInfo.PlayerStatus[AccountId] == -1){ //set casters to last in table score
				Scores::SetPlayerMatchPoints(Score, -S_MaxPointLoss - Server_MatchInfo.ParticipantsNb - 1);
			}
		//declare Integer PlayerPoint = Scores::GetPlayerMatchPoints(Player.Score);		
		}
	}
	
	Server_MatchInfo.FirstRoundOver = True;
	UpdateNameDisplay();
	MB_Sleep(3000);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	
	SetPlayersState(Server_MatchInfo);
	if (MatchIsOver()){
		MB_StopMap();
	}
}
***

***Match_EndMap***
***
Log::Log("End Map");
declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
foreach (Score in Scores) {
	declare AccountId = Score.User.Login; 
	Server_MatchInfo.PlayerStatus[AccountId] = 1;
}
SetPlayersState(Server_MatchInfo);
MB_StopMatch();
//SetPlayersState(Server_MatchInfo);
if (!MB_MapIsRunning() && MB_MatchIsRunning()) MB_SkipPodiumSequence();

Race::SortScores(Race::C_Sort_TotalPoints);
Scores::SetPlayerWinner(Scores::GetBestPlayer(Scores::C_Sort_MatchPoints));
***



Void SetPlayersState(K_MatchInfo Server_MatchInfo){
	foreach (Score in Scores) {
		if (Score != Null) {
		declare AccountId = Score.User.Login; // Login
		//declare AccountId = Score.User.WebServicesUserId; // ID
		declare Integer PlayerStatus = Server_MatchInfo.PlayerStatus[AccountId]; //Get player status
		declare DoExist = Server_MatchInfo.PlayerIsOnServer.exists(AccountId); //Check if the player is in game
		if(Score.User != Null && PlayerStatus <= 0 && DoExist){
			ServerAdmin.ForceSpectator(Score.User,CServerAdmin::ESpecMode::SpectatorForced);
		}else if(Score.User != Null && PlayerStatus > 0 && DoExist){
			ServerAdmin.ForceSpectator(Score.User,CServerAdmin::ESpecMode::PlayerSelectable);
		}
		}
	}
}


// // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// // Functions
// // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// /** Update the scores table footer text
//  *
//  *	@param	_PointsLimit							The points limit
//  *	@param	_RoundsPerMap							The number of rounds per map
//  *	@param	_MapsPerMatch							The number of maps per match
//  *	@param	_ValidRoundsNb						Number of valid rounds played
//  */
// Void UpdateScoresTableFooter(Integer _PointsLimit, Integer _RoundsPerMap, Integer _MapsPerMatch, Integer _ValidRoundsNb) {
// 	declare Text[] Parts;
// 	declare Text Message = "";
// 	// if (_PointsLimit > 0) {
// 	// 	if (Parts.count > 0) Message ^= "\n";
// 	// 	Message ^= """%{{{Parts.count + 1}}}{{{_PointsLimit}}}""";
// 	// 	//L16N [Rounds] Number of points to reach to win the match.
// 	// 	Parts.add(_("Points limit : "));
// 	// }
// 	if (_RoundsPerMap > 0) {
// 		if (Parts.count > 0) Message ^= "\n";
// 		Message ^= """%{{{Parts.count + 1}}}{{{ML::Min(_ValidRoundsNb+1, _RoundsPerMap)}}}/{{{_RoundsPerMap}}}""";
// 		//L16N [Rounds] Number of rounds played during the map.
// 		Parts.add(_("Rounds : "));
// 	}
// 	if (_MapsPerMatch > 0) {
// 		if (Parts.count > 0) Message ^= "\n";
// 		Message ^= """%{{{Parts.count + 1}}}{{{MB_GetMapCount()}}}/{{{_MapsPerMatch}}}""";
// 		//L16N [Rounds] Number of maps played during the match.
// 		Parts.add(_("Maps : "));
// 	}
	
// 	switch (Parts.count) {
// 		case 0: UIModules_ScoresTable::SetFooterInfo(Message);
// 		case 1: UIModules_ScoresTable::SetFooterInfo(TL::Compose(Message, Parts[0]));
// 		case 2: UIModules_ScoresTable::SetFooterInfo(TL::Compose(Message, Parts[0], Parts[1]));
// 		case 3: UIModules_ScoresTable::SetFooterInfo(TL::Compose(Message, Parts[0], Parts[1], Parts[2]));
// 	}
// }

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the time left to the players to finish the round after the first player
 *
 *	@return 		The time left in ms
 */
Integer GetFinishTimeout(Integer _FinishTimeout) {
	declare Integer FinishTimeout = 0;
	
	if (_FinishTimeout >= 0) {
		FinishTimeout = _FinishTimeout * 1000;
	} else {
		FinishTimeout = 5000;
		if (Map.TMObjective_IsLapRace && Race::GetLapsNb() > 0 && Map.TMObjective_NbLaps > 0) {
			FinishTimeout += ((Map.TMObjective_AuthorTime / Map.TMObjective_NbLaps) * Race::GetLapsNb()) / 6;
		} else {
			FinishTimeout += Map.TMObjective_AuthorTime / 6;
		}
	}
	
	return Now + FinishTimeout;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Compute the latest race scores
Void ComputeLatestRaceScores() { //Soustract the players points
    Race::SortScores(Race::C_Sort_PrevRaceTime);

    // Points distributed between all players
	declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
    declare Integer I = 0;
	declare Real PPoints = ML::ToReal((S_PenalityPointforDNF * S_MaxPointLoss) / 100);
	declare Integer PenalityPoints = ML::FloorInteger(PPoints);
    foreach (Score in Scores) {
		declare AccountId = Score.User.Login;
		if(Score != Null && Server_MatchInfo.PlayerStatus[AccountId] == 1){
			if(Server_MatchInfo.NbOfRoundPlayers > 1) { //Development if, only because when you are alone it crash. divided by zero.
				if (Scores::GetPlayerPrevRaceTime(Score) > 0) {
					declare Real Points = ML::ToReal(I *S_MaxPointLoss/(Server_MatchInfo.NbOfRoundPlayers - 1));		
					declare Integer FloorPoints = ML::FloorInteger(Points);
					FloorPoints = ML::Min(FloorPoints, S_MaxPointLoss);
					Scores::SetPlayerRoundPoints(Score, -FloorPoints);
					I += 1;
				} else {
					
					Scores::SetPlayerRoundPoints(Score,-S_MaxPointLoss - PenalityPoints);
				}		
			}
		}
		
    }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Compute the map scores
Void ComputeScores() {
	Scores::EndRound();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Whether the player has been eliminated or not
 *
 *@return										True if the player has been eliminated
 *													False Otherwise
 */
 Boolean PlayerIsAlive(Text _AccountId) {
	if (_AccountId == "") return False;
	declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	return (
		//True
		Server_MatchInfo.PlayerStatus[_AccountId] == 1
	);
}

//Check if the player is KO and change its name in consequence same for the winner 
Void UpdateNameDisplay(){
	declare Text[][Text] CustomPoints = []; 
	declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
	foreach (Score in Scores) {
			if(Score != Null){
				declare AccountId = Score.User.Login; 
				if(Server_MatchInfo.PlayerStatus[AccountId] == -1){
						CustomPoints[Score.User.WebServicesUserId] = [("|Status|CASTER"), "64A"];
				}else if(Server_MatchInfo.PlayerStatus[AccountId] == 2){
						CustomPoints[Score.User.WebServicesUserId] = [("|Status|WINNER"), "0f0"];
				}else{
					if(!PlayerIsAlive(AccountId)){	
						CustomPoints[Score.User.WebServicesUserId] = [("|Status|K.O."), "f00"];
					}
				
				}		
			}	
	}
	UIModules_ScoresTable::SetCustomPoints(CustomPoints);
	
}

// ---------------------------------- //
/** Convert the points repartition Text
 *	to an Integer array
 *
 *	@param	_PointsRepartition				The Text points repartition
 *
 *	@return														The Integer[] points repartition
 */
 Text[] ConvertCastersLogin(Text _CastersLogins) {
	declare Text[] CastersLogins;
	declare Logins = TL::Split(",", _CastersLogins);
	foreach (Login in Logins) {
		CastersLogins.add(Login);
	}
	
	return CastersLogins;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if we should go to the next match
 *

 */
Boolean MatchIsOver() {
		declare Integer I = 0;
		declare K_MatchInfo Server_MatchInfo for This = K_MatchInfo {};
		declare Text WinnerLogin;
		foreach (Score in Scores) {
			if(Score != Null)
				{
				//declare AccountId = Player.Score.User.WebServicesUserId; 
				declare AccountId = Score.User.Login; 
				if(PlayerIsAlive(AccountId)){
					WinnerLogin = AccountId;
					I+=1;
				}	
			}
		}
		if(I == 1){
			Server_MatchInfo.PlayerStatus[WinnerLogin] = 2;
			UpdateNameDisplay();
			return True;
		}
		return False;
		
		
}